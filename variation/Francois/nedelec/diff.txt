Only in /Users/saito/tmp/SFMT-src-1.2: CHANGE-LOG.txt
Only in /Users/saito/tmp/SFMT-src-1.2: FILES.txt
Only in /Users/saito/tmp/SFMT-src-1.2: LICENSE.txt
Only in /Users/saito/tmp/SFMT-src-1.2: Makefile
Only in /Users/saito/tmp/SFMT-src-1.2: README.txt
diff ./SFMT-alti.c /Users/saito/tmp/SFMT-src-1.2/SFMT-alti.c
1,9d0
< #warning "SFMT using altivec"
< 
< union W128_T {
<     vector unsigned int s;
<     uint32_t u[4];
< };
< 
< typedef union W128_T w128_t;
< 
54c45
< void gen_rand_all(w128_t sfmt[]) {
---
> inline static void gen_rand_all(void) {
74d64
< 
82c72
< static void gen_rand_array(w128_t sfmt[], w128_t array[], int size) {
---
> inline static void gen_rand_array(w128_t array[], int size) {
118a109,126
> #ifndef ONLY64
> /**
>  * This function swaps high and low 32-bit of 64-bit integers in user
>  * specified array.
>  *
>  * @param array an 128-bit array to be swaped.
>  * @param size size of 128-bit array.
>  */
> inline static void swap(w128_t array[], int size) {
>     int i;
>     const vector unsigned char perm = (vector unsigned char)
> 	(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
> 
>     for (i = 0; i < size; i++) {
> 	array[i].s = vec_perm(array[i].s, (vector unsigned int)perm, perm);
>     }
> }
> #endif
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT-alti.h
diff ./SFMT-params.h /Users/saito/tmp/SFMT-src-1.2/SFMT-params.h
3c3
< #warning "MEXP is not defined. I assume MEXP is 19937."
---
>   #warning "MEXP is not defined. I assume MEXP is 19937."
5c5
< #define MEXP 19937
---
>   #define MEXP 19937
18c18
< #define N32 (N*4)
---
> #define N32 (N * 4)
21c21
< #define N64 (N*2)
---
> #define N64 (N * 2)
diff ./SFMT-sse2.c /Users/saito/tmp/SFMT-src-1.2/SFMT-sse2.c
16,26d15
< #warning "SFMT using SSE2"
< 
< #include <emmintrin.h>
< 
< union W128_T {
<     __m128i si;
<     uint32_t u[4];
< };
< 
< typedef union W128_T w128_t;
< 
49c38,39
<     return _mm_xor_si128(z, y);
---
>     z = _mm_xor_si128(z, y);
>     return z;
53c43
<  * This function fills the internal state array with pseudorandom
---
>  * This function fills the internal state array with psedorandom
56c46
< void gen_rand_all(w128_t sfmt[]) {
---
> inline void gen_rand_all(void) {
77d66
< 
79c68
<  * This function fills the user-specified array with pseudorandom
---
>  * This function fills the user-specified array with psedorandom
85c74
< static void gen_rand_array(w128_t sfmt[], w128_t array[], int size) {
---
> inline static void gen_rand_array(w128_t array[], int size) {
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT-sse2.h
Only in .: SFMT-std.c
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.11213.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.1279.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.132049.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.19937.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.2281.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.4253.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.44497.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.607.out.txt
Only in /Users/saito/tmp/SFMT-src-1.2: SFMT.86243.out.txt
diff ./SFMT.c /Users/saito/tmp/SFMT-src-1.2/SFMT.c
14,15c14
< //#include <assert.h>
< #define assert(x)
---
> #include <assert.h>
20,22c19,21
<   #include "SFMT-alti.c"
< #elif defined __SSE2__
<   #include "SFMT-sse2.c"
---
>   #include "SFMT-alti.h"
> #elif defined(SSE2)
>   #include "SFMT-sse2.h"
24,25c23,32
<   #include "SFMT-std.c"
< #endif
---
> /*------------------------------------------
>   128-bit SIMD like data type for standard C
>   ------------------------------------------*/
> /** 128-bit data structure */
> struct W128_T {
>     uint32_t u[4];
> };
> 
> /** 128-bit data type */
> typedef struct W128_T w128_t;
26a34
> #endif
33,40c41,47
< w128_t sfmt[N];
< 
< /** the 32bit integer pointer to the state array */
< uint32_t *psfmt32 = (uint32_t*)sfmt;
< 
< /** the 64bit integer pointer to the state array */
< uint64_t *psfmt64 = (uint64_t*)sfmt;
< 
---
> static w128_t sfmt[N];
> /** the 32bit integer pointer to the 128-bit internal state array */
> static uint32_t *psfmt32 = &sfmt[0].u[0];
> #if !defined(BIG_ENDIAN64) || defined(ONLY64)
> /** the 64bit integer pointer to the 128-bit internal state array */
> static uint64_t *psfmt64 = (uint64_t *)&sfmt[0].u[0];
> #endif
42c49
< int idx;
---
> static int idx;
45c52
< int initialized = 0;
---
> static int initialized = 0;
47,51c54
< uint32_t parity[4] = {PARITY1, PARITY2, PARITY3, PARITY4};
< 
< char *get_idstring(void)       { return IDSTR; }
< int get_min_array_size32(void) { return N*4; }
< int get_min_array_size64(void) { return N*2; }
---
> static uint32_t parity[4] = {PARITY1, PARITY2, PARITY3, PARITY4};
55a59,69
> inline static int idxof(int i);
> inline static void rshift128(w128_t *out,  w128_t const *in, int shift);
> inline static void lshift128(w128_t *out,  w128_t const *in, int shift);
> inline static void gen_rand_all(void);
> inline static void gen_rand_array(w128_t array[], int size);
> inline static uint32_t func1(uint32_t x);
> inline static uint32_t func2(uint32_t x);
> static void period_certification(void);
> #if defined(BIG_ENDIAN64) && !defined(ONLY64)
> inline static void swap(w128_t array[], int size);
> #endif
57,69c71,75
< /**
< * This function generates and returns 32-bit pseudorandom number.
<  * init_gen_rand or init_by_array must be called before this function.
<  * @return 32-bit pseudorandom number
<  */
< uint32_t gen_rand32(void) {
<     assert(initialized && "init_gen_rand() or init_by_array() must be called first");
<     if (idx >= N32) {
<         gen_rand_all(sfmt);
<         idx = 0;
<     }
<     return psfmt32[idx++];
< }
---
> #if defined(ALTIVEC)
>   #include "SFMT-alti.c"
> #elif defined(SSE2)
>   #include "SFMT-sse2.c"
> #endif
72,87d77
< * This function generates and returns 64-bit pseudorandom number.
<  * init_gen_rand or init_by_array must be called before this function.
<  * The function gen_rand64 should not be called after gen_rand32,
<  * unless an initialization is again executed. 
<  * @return 64-bit pseudorandom number
<  */
< uint64_t gen_rand64(void) {
<     assert(initialized && "init_gen_rand() or init_by_array() must be called first");
<     if (idx >= N32-1) {
<         gen_rand_all(sfmt);
<         idx = 0;
<     }
<     return ((uint64_t)psfmt32[idx++] << 32) | psfmt32[idx++];
< }
<     
< /**
99a90,154
> /**
>  * This function simulates SIMD 128-bit right shift by the standard C.
>  * The 128-bit integer given in in is shifted by (shift * 8) bits.
>  * This function simulates the LITTLE ENDIAN SIMD.
>  * @param out the output of this function
>  * @param in the 128-bit data to be shifted
>  * @param shift the shift value
>  */
> #ifdef ONLY64
> inline static void rshift128(w128_t *out, w128_t const *in, int shift) {
>     uint64_t th, tl, oh, ol;
> 
>     th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
>     tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
> 
>     oh = th >> (shift * 8);
>     ol = tl >> (shift * 8);
>     ol |= th << (64 - shift * 8);
>     out->u[0] = (uint32_t)(ol >> 32);
>     out->u[1] = (uint32_t)ol;
>     out->u[2] = (uint32_t)(oh >> 32);
>     out->u[3] = (uint32_t)oh;
> }
> #else
> inline static void rshift128(w128_t *out, w128_t const *in, int shift) {
>     uint64_t th, tl, oh, ol;
> 
>     th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
>     tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
> 
>     oh = th >> (shift * 8);
>     ol = tl >> (shift * 8);
>     ol |= th << (64 - shift * 8);
>     out->u[1] = (uint32_t)(ol >> 32);
>     out->u[0] = (uint32_t)ol;
>     out->u[3] = (uint32_t)(oh >> 32);
>     out->u[2] = (uint32_t)oh;
> }
> #endif
> /**
>  * This function simulates SIMD 128-bit left shift by the standard C.
>  * The 128-bit integer given in in is shifted by (shift * 8) bits.
>  * This function simulates the LITTLE ENDIAN SIMD.
>  * @param out the output of this function
>  * @param in the 128-bit data to be shifted
>  * @param shift the shift value
>  */
> #ifdef ONLY64
> inline static void lshift128(w128_t *out, w128_t const *in, int shift) {
>     uint64_t th, tl, oh, ol;
> 
>     th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
>     tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
> 
>     oh = th << (shift * 8);
>     ol = tl << (shift * 8);
>     oh |= tl >> (64 - shift * 8);
>     out->u[0] = (uint32_t)(ol >> 32);
>     out->u[1] = (uint32_t)ol;
>     out->u[2] = (uint32_t)(oh >> 32);
>     out->u[3] = (uint32_t)oh;
> }
> #else
> inline static void lshift128(w128_t *out, w128_t const *in, int shift) {
>     uint64_t th, tl, oh, ol;
100a156,167
>     th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
>     tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
> 
>     oh = th << (shift * 8);
>     ol = tl << (shift * 8);
>     oh |= tl >> (64 - shift * 8);
>     out->u[1] = (uint32_t)(ol >> 32);
>     out->u[0] = (uint32_t)ol;
>     out->u[3] = (uint32_t)(oh >> 32);
>     out->u[2] = (uint32_t)oh;
> }
> #endif
102a170,291
>  * This function represents the recursion formula.
>  * @param r output
>  * @param a a 128-bit part of the internal state array
>  * @param b a 128-bit part of the internal state array
>  * @param c a 128-bit part of the internal state array
>  * @param d a 128-bit part of the internal state array
>  */
> #ifdef ONLY64
> inline static void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
> 				w128_t *d) {
>     w128_t x;
>     w128_t y;
> 
>     lshift128(&x, a, SL2);
>     rshift128(&y, c, SR2);
>     r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK2) ^ y.u[0] 
> 	^ (d->u[0] << SL1);
>     r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK1) ^ y.u[1] 
> 	^ (d->u[1] << SL1);
>     r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK4) ^ y.u[2] 
> 	^ (d->u[2] << SL1);
>     r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK3) ^ y.u[3] 
> 	^ (d->u[3] << SL1);
> }
> #else
> inline static void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
> 				w128_t *d) {
>     w128_t x;
>     w128_t y;
> 
>     lshift128(&x, a, SL2);
>     rshift128(&y, c, SR2);
>     r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK1) ^ y.u[0] 
> 	^ (d->u[0] << SL1);
>     r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK2) ^ y.u[1] 
> 	^ (d->u[1] << SL1);
>     r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK3) ^ y.u[2] 
> 	^ (d->u[2] << SL1);
>     r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK4) ^ y.u[3] 
> 	^ (d->u[3] << SL1);
> }
> #endif
> 
> #if (!defined(ALTIVEC)) && (!defined(SSE2))
> /**
>  * This function fills the internal state array with pseudorandom
>  * integers.
>  */
> inline static void gen_rand_all(void) {
>     int i;
>     w128_t *r1, *r2;
> 
>     r1 = &sfmt[N - 2];
>     r2 = &sfmt[N - 1];
>     for (i = 0; i < N - POS1; i++) {
> 	do_recursion(&sfmt[i], &sfmt[i], &sfmt[i + POS1], r1, r2);
> 	r1 = r2;
> 	r2 = &sfmt[i];
>     }
>     for (; i < N; i++) {
> 	do_recursion(&sfmt[i], &sfmt[i], &sfmt[i + POS1 - N], r1, r2);
> 	r1 = r2;
> 	r2 = &sfmt[i];
>     }
> }
> 
> /**
>  * This function fills the user-specified array with pseudorandom
>  * integers.
>  *
>  * @param array an 128-bit array to be filled by pseudorandom numbers.  
>  * @param size number of 128-bit pseudorandom numbers to be generated.
>  */
> inline static void gen_rand_array(w128_t array[], int size) {
>     int i, j;
>     w128_t *r1, *r2;
> 
>     r1 = &sfmt[N - 2];
>     r2 = &sfmt[N - 1];
>     for (i = 0; i < N - POS1; i++) {
> 	do_recursion(&array[i], &sfmt[i], &sfmt[i + POS1], r1, r2);
> 	r1 = r2;
> 	r2 = &array[i];
>     }
>     for (; i < N; i++) {
> 	do_recursion(&array[i], &sfmt[i], &array[i + POS1 - N], r1, r2);
> 	r1 = r2;
> 	r2 = &array[i];
>     }
>     for (; i < size - N; i++) {
> 	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
> 	r1 = r2;
> 	r2 = &array[i];
>     }
>     for (j = 0; j < 2 * N - size; j++) {
> 	sfmt[j] = array[j + size - N];
>     }
>     for (; i < size; i++, j++) {
> 	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
> 	r1 = r2;
> 	r2 = &array[i];
> 	sfmt[j] = array[i];
>     }
> }
> #endif
> 
> #if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(ALTIVEC)
> inline static void swap(w128_t array[], int size) {
>     int i;
>     uint32_t x, y;
> 
>     for (i = 0; i < size; i++) {
> 	x = array[i].u[0];
> 	y = array[i].u[2];
> 	array[i].u[0] = array[i].u[1];
> 	array[i].u[2] = array[i].u[3];
> 	array[i].u[1] = x;
> 	array[i].u[3] = y;
>     }
> }
> #endif
> /**
156a346,371
> /**
>  * This function returns the identification string.
>  * The string shows the word size, the Mersenne exponent,
>  * and all parameters of this generator.
>  */
> char *get_idstring(void) {
>     return IDSTR;
> }
> 
> /**
>  * This function returns the minimum size of array used for \b
>  * fill_array32() function.
>  * @return minimum size of array used for fill_array32() function.
>  */
> int get_min_array_size32(void) {
>     return N32;
> }
> 
> /**
>  * This function returns the minimum size of array used for \b
>  * fill_array64() function.
>  * @return minimum size of array used for fill_array64() function.
>  */
> int get_min_array_size64(void) {
>     return N64;
> }
157a373,403
> #ifndef ONLY64
> /**
>  * This function generates and returns 32-bit pseudorandom number.
>  * init_gen_rand or init_by_array must be called before this function.
>  * @return 32-bit pseudorandom number
>  */
> inline uint32_t gen_rand32(void) {
>     uint32_t r;
> 
>     assert(initialized);
>     if (idx >= N32) {
> 	gen_rand_all();
> 	idx = 0;
>     }
>     r = psfmt32[idx++];
>     return r;
> }
> #endif
> /**
>  * This function generates and returns 64-bit pseudorandom number.
>  * init_gen_rand or init_by_array must be called before this function.
>  * The function gen_rand64 should not be called after gen_rand32,
>  * unless an initialization is again executed. 
>  * @return 64-bit pseudorandom number
>  */
> inline uint64_t gen_rand64(void) {
> #if defined(BIG_ENDIAN64) && !defined(ONLY64)
>     uint32_t r1, r2;
> #else
>     uint64_t r;
> #endif
158a405,406
>     assert(initialized);
>     assert(idx % 2 == 0);
159a408,424
>     if (idx >= N32) {
> 	gen_rand_all();
> 	idx = 0;
>     }
> #if defined(BIG_ENDIAN64) && !defined(ONLY64)
>     r1 = psfmt32[idx];
>     r2 = psfmt32[idx + 1];
>     idx += 2;
>     return ((uint64_t)r2 << 32) | r1;
> #else
>     r = psfmt64[idx / 2];
>     idx += 2;
>     return r;
> #endif
> }
> 
> #ifndef ONLY64
185c450
< void fill_array32(uint32_t array[], int size) {
---
> inline void fill_array32(uint32_t array[], int size) {
191c456
<     gen_rand_array(sfmt, (w128_t *)array, size / 4);
---
>     gen_rand_array((w128_t *)array, size / 4);
193a459
> #endif
220c486
< void fill_array64(uint64_t array[], int size) {
---
> inline void fill_array64(uint64_t array[], int size) {
226c492
<     gen_rand_array(sfmt, (w128_t *)array, size / 2);
---
>     gen_rand_array((w128_t *)array, size / 2);
228d493
< }
229a495,498
> #if defined(BIG_ENDIAN64) && !defined(ONLY64)
>     swap((w128_t *)array, size /2);
> #endif
> }
275c544
<     memset(psfmt32, 0x8b, N*16);
---
>     memset(sfmt, 0x8b, sizeof(sfmt));
diff ./SFMT.h /Users/saito/tmp/SFMT-src-1.2/SFMT.h
16,17c16,28
<  * @note We assume that your system has stdint.h.  If your system
<  * doesn't have stdint.h, you have to typedef uint32_t and uint64_t,
---
>  * @note We assume that your system has inttypes.h.  If your system
>  * doesn't have inttypes.h, you have to typedef uint32_t and uint64_t,
>  * and you have to define PRIu64 and PRIx64 in this file as follows:
>  * @verbatim
>  typedef unsigned int uint32_t
>  typedef unsigned long long uint64_t  
>  #define PRIu64 "llu"
>  #define PRIx64 "llx"
> @endverbatim
>  * uint32_t must be exactly 32-bit unsigned integer type (no more, no
>  * less), and uint64_t must be exactly 64-bit unsigned integer type.
>  * PRIu64 and PRIx64 are used for printf function to print 64-bit
>  * unsigned int and 64-bit unsigned int in hexadecimal format.
24d34
< #include <stdint.h>
25a36,57
> #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
>   #include <inttypes.h>
> #elif defined(_MSC_VER)
>   typedef unsigned int uint32_t;
>   typedef unsigned long long uint64_t;
>   #define inline
> #else
>   #include <inttypes.h>
>   #if defined(__GNUC__)
>     #define inline __inline__
>   #endif
> #endif
> 
> #ifndef PRIu64
>   #if defined(_MSC_VER)
>     #define PRIu64 "I64u"
>     #define PRIx64 "I64x"
>   #else
>     #define PRIu64 "llu"
>     #define PRIx64 "llx"
>   #endif
> #endif
26a59,62
> inline uint32_t gen_rand32(void);
> inline uint64_t gen_rand64(void);
> inline void fill_array32(uint32_t array[], int size);
> inline void fill_array64(uint64_t array[], int size);
29,50c65,67
< 
< /**
< * This function generates and returns 32-bit pseudorandom number.
<  * init_gen_rand or init_by_array must be called before this function.
<  * @return 32-bit pseudorandom number
<  */
< uint32_t gen_rand32(void);
< /**
< * This function generates and returns 64-bit pseudorandom number.
<  * init_gen_rand or init_by_array must be called before this function.
<  * The function gen_rand64 should not be called after gen_rand32,
<  * unless an initialization is again executed. 
<  * @return 64-bit pseudorandom number
<  */
< uint64_t gen_rand64(void);
< 
< void fill_array32(uint32_t array[], int size);
< void fill_array64(uint64_t array[], int size);
< 
< inline char *get_idstring(void);
< inline int get_min_array_size32(void);
< inline int get_min_array_size64(void);
---
> char *get_idstring(void);
> int get_min_array_size32(void);
> int get_min_array_size64(void);
Only in /Users/saito/tmp/SFMT-src-1.2: check.sh
Only in .: diff.txt
Only in /Users/saito/tmp/SFMT-src-1.2: html
Only in .: makefile
diff ./test.c /Users/saito/tmp/SFMT-src-1.2/test.c
19c19,21
< #include "SFMT.h"
---
> #if defined(__ppc__) && !defined(BIG_ENDIAN64)
>   #define BIG_ENDIAN64
> #endif
21,22c23
< #define PRIx64 "llx"
< #define PRIu64 "llu"
---
> #include "SFMT.c"
32a34,40
> #if defined(ALTIVEC)
> static vector unsigned int array1[BLOCK_SIZE / 4];
> static vector unsigned int array2[10000 / 4];
> #elif defined(SSE2)
> static __m128i array1[BLOCK_SIZE / 4];
> static __m128i array2[10000 / 4];
> #else
34a43
> #endif
36c45
< 
---
> #ifndef ONLY64
148c157
< 
---
> #endif
