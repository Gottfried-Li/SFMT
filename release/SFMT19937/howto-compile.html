<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html" />
    <title>How to compile SFMT</title>
    <style type="text/css">
      BLOCKQUOTE {background-color:#a0ffa0}
    </style>
  </head>
  <body>
    <h2> How to compile SFMT </h2>

    <p>
      This document explains how to compile SFMT19937 for users who
      are using UNIX like systems (for example Linux, Free BSD,
      cygwin, osx, etc) on terminal. I can't help those who use IDE
      (Integrated Development Environment,) please see your IDE's help
      to use SIMD feature of your CPU.
    </p>

    <h3>1. First Step: Compile test programs using Makefile.</h3>
    <h4>1-1. Compile standard C test program.</h4>
    <p>
      Check if SFMT19937.c and Makefile are in your current directory.
      If not, <strong>cd</strong> to the directory where they exist.
      Then, type
    </p>
      <blockquote>
	<pre>make test-std32</pre>
      </blockquote>
    <p>
      If it causes an error, try to type
    </p>
    <blockquote>
      <pre>cc -o test-std32 test32.c</pre>
    </blockquote>
    <p>
      or try to type
    </p>
    <blockquote>
      <pre>gcc -o test-std32 test32.c</pre>
    </blockquote>
    <p>
      If success, then check the test program. Type
    </p>
    <blockquote>
      <pre>./test-std32</pre>
    </blockquote>
    <p>
      You will see many random numbers displayed on your screen.
      If you want to know the generation speed of SFMT, type
    </p>
    <blockquote>
      <pre>./test-std32 -s</pre>
    </blockquote>

    <h4>1-2. Compile SSE2 test program.</h4>
    <p>
      If your CPU supports SSE2 and you can use gcc version 3.4 or later,
      you can make test-sse32. To do this, type
    </p>
    <blockquote>
      <pre>make test-sse32</pre>
    </blockquote>
    <p>or type</p>
    <blockquote>
      <pre>gcc -O3 -msse2 -fno-strict-aliasing -DSSE2=1 -o test-sse32 test32.c</pre>
    </blockquote>
    <p>If everything works well,</p>
    <blockquote>
      <pre>./test-sse32 -s</pre>
    </blockquote>
      <p>shows much shorter time than <strong>test-std32 -s</strong>.</p>

    <h4>1-3. Compile AltiVec test program.</h4>
    <p>
      If you are using Macintosh computer with PowerPC G4 or G5, and
      your gcc version is later 3.3, you can make test-alti32. To
      do this, type
    </p>
    <blockquote>
      <pre>make test-alti32</pre>
    </blockquote>
    <p>or type</p>
    <blockquote>
      <pre>gcc -O3 -faltivec -fno-strict-aliasing -DALTIVEC=1 -o test-alti32 test32.c</pre>
    </blockquote>
    <p>If everything works well,</p>
    <blockquote>
      <pre>./test-alti32 -s</pre>
    </blockquote>
    <p>shows much shorter time than <strong>test-std32 -s</strong>.</p>

    <h3>2. Second Step: Use SFMT pseudorandom number generator with
    your C program.</h3>
    <h4>2-1. Use sequential call and static link.</h4>
    <p>
      Here is a very simple program <strong>sample1.c</strong> which
      calculate PI using Monte-Carlo method.
    </p>
    <blockquote>
      <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "sfmt19937.h"

int main(int argc, char* argv[]) {
    int i, cnt, seed;
    double x, y, pi;
    const int NUM = 10000;

    if (argc &gt;= 2) {
	seed = strtol(argv[1], NULL, 10);
    } else {
	seed = 12345;
    }
    cnt = 0;
    init_gen_rand(seed);
    for (i = 0; i &lt; 10000; i++) {
	x = genrand_res53();
	y = genrand_res53();
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample1.c</strong> with sfmt19937.c, type</p>
    <blockquote>
      <pre>gcc -o sample1 sfmt19937.c sample1.c</pre>
    </blockquote>
    <p>If your CPU supports SSE2 and you want to use optimized SFMT for
      SSE2, type</p>
    <blockquote>
      <pre>gcc -msse2 -o sample1 sfmt19937-sse2.c sample1.c</pre>
    </blockquote>
    <p>If your CPU supports AltiVec and you want to use optimized SFMT
      for AltiVec, type</p>
    <blockquote>
      <pre>gcc -faltivec -o sample1 sfmt19937-alti32.c sample1.c</pre>
    </blockquote>

    <h4>2-2. Use block call and static link.</h4>
    <p>
      Here is <strong>sample2.c</strong> which is modified sample1.c.
      The block call <strong>fill_array64</strong> is much faster than
      sequential call, but it needs an aligned memory.
    </p>
    <blockquote>
      <pre>
#define _XOPEN_SOURCE 600
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "sfmt19937.h"

int main(int argc, char* argv[]) {
    int i, j, cnt, seed;
    double x, y, pi;
    const int NUM = 10000;
    const int R_SIZE = 2 * NUM;
    uint64_t *array;

    if (argc &gt;= 2) {
	seed = strtol(argv[1], NULL, 10);
    } else {
	seed = 12345;
    }
#ifdef __APPLE__
    array = malloc(sizeof(uint64_t) * R_SIZE);
    if (array == NULL) {
	printf("can't allocate memory.");
	return 1;
    }
#else
    if (posix_memalign(&amp;array, 16, sizeof(uint64_t) * R_SIZE) != 0) {
	printf("can't allocate memory.");
	return 1;
    }
#endif
    cnt = 0;
    j = 0;
    init_gen_rand(seed);
    fill_array64(array, R_SIZE);
    for (i = 0; i &lt; 10000; i++) {
	x = to_res53(array[j++]);
	y = to_res53(array[j++]);
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    free(array);
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample2.c</strong> with sfmt19937.c, type</p>
    <blockquote>
      <pre>gcc -o sample2 sfmt19937.c sample2.c</pre>
    </blockquote>
    <p>If your CPU supports SSE2 and you want to use optimized SFMT for
      SSE2, type</p>
    <blockquote>
      <pre>gcc -msse2 -o sample2 sfmt19937-sse2.c sample2.c</pre>
    </blockquote>
    <p>If your CPU supports AltiVec and you want to use optimized SFMT
      for AltiVec, type</p>
    <blockquote>
      <pre>gcc -faltivec -o sample2 sfmt19937-alti32.c sample2.c</pre>
    </blockquote>
    <p>or type</p>
    <blockquote>
      <pre>gcc -faltivec -o sample2 sfmt19937-alti64.c sample2.c</pre>
    </blockquote>
    <p>The difference between sfmt19937-alti32.c and sfmt19937-alti64.c is:
      sfmt19937-alti32.c support 32-bit and 64-bit output, but 64-bit output
      is slower, on the other hand, sfmt19937-alti64.c support 64-bit output
      only, but it's faster than sfmt19937-alti32.c
    </p>
    <h4>2-3. Use sequential call and inline functions.</h4>
    <p>
      Here is <strong>sample3.c</strong> which is modified sample1.c.
      This is very similar to sample1.c. The difference is only one line.
      It include <strong>"sfmt19937.c"</strong> instead of <strong>"sfmt19937.h"
      </strong>.
    </p>
    <blockquote>
      <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "sfmt19937.c"

int main(int argc, char* argv[]) {
    int i, cnt, seed;
    double x, y, pi;
    const int NUM = 10000;

    if (argc &gt;= 2) {
	seed = strtol(argv[1], NULL, 10);
    } else {
	seed = 12345;
    }
    cnt = 0;
    init_gen_rand(seed);
    for (i = 0; i &lt; 10000; i++) {
	x = genrand_res53();
	y = genrand_res53();
	if (x * x + y * y &lt; 1.0) {
	    cnt++;
	}
    }
    pi = (double)cnt / NUM * 4;
    printf("%lf\n", pi);
    return 0;
}
      </pre>
    </blockquote>
    <p>To compile <strong>sample3.c</strong>, type</p>
    <blockquote>
      <pre>gcc -o sample3 sample3.c</pre>
    </blockquote>
    <p>If your CPU supports SSE2 and you want to use optimized SFMT for
      SSE2, change "sfmt19937.c" in sample3.c to "sfmt19937-sse2.c"
      and type</p>
    <blockquote>
      <pre>gcc -msse2 -o sample3 sample3.c</pre>
    </blockquote>
    <p>If your CPU supports AltiVec and you want to use optimized SFMT
      for AltiVec, change "sfmt19937.c" in sample3.c to
      "sfmt19937-alti32.c" or "sfmt19937-alti64.c" and type</p>
    <blockquote>
      <pre>gcc -faltivec -o sample3 sample3.c</pre>
    </blockquote>
  </body>
</html>
